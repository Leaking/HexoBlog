---
title: 关于字符编码的一切
date: 2017-08-19 19:16:06
toc: true
tags: Android
---

字符编码应用广泛，除了用于处理字符和二进制数据的对应关系，也应用于譬如Baes64编码和URL编码这种网络中的编码。这里对相关知识做一次全面的总结，写下我的理解。

本文将讲解以下几个点：

+ ASCII的缺陷
+ Unicode的历史和发展
+ UTF-8的设计和原理
+ Base64编码
+ URL编码


## ASCII码

ASCII，全称American Standard Code for Information Interchange。规定了拉丁字符和二进制位之间的对应关系，这个标准描述了拉丁字符中128个字符，其中包含33个控制字符（比如换行符，换页符），95个可显示字符（其中包括大小写字母各26个，10个阿拉伯数字，以及其他标点符号）。2^7=128，所以使用一个字节就可以描述ASCII码标准中的128个字符，并且只需要使用前7位，最高位恒为0。ASCII码的对应关系见以下表格

![HASCII码](/images/ascii.png)

ASCII码存在一个致命的缺陷，就是涵盖的字符只有拉丁字符，所以无法适用于其他语言的字符，比如中文，日语等等，于是急需一套具备普适性的编码标准，于是出现了UNICODE。


## UNICODE

关于Unicode的介绍，要先从字符集的发展历史讲起，让我们来一次性理清平时能见到的种种字符集的来龙去脉。

最开始，计算机在美国发明，于是美国人发明了只支持英文的ASCII码字符集，但随着计算机在全世界普及，需要面对其他语言的字符，于是其他语言的地区陆续推出自己的字符集，并且基本都向下兼容ASCII。

+ ISO 8859-1

这是西欧国家推出了字符集，ISO 8859-1的特点是扩充了ASCII，在空置的128-255的范围内，加入了其他字符，比如葡萄牙语、德语等等。ISO 8859-1是一个单字节的字符集。

+ GB2312、GBK、GB18030

这是针对简体中文推出的三个字符集(顺便提一点，有一个繁体中文字符集叫big5)，它们都是双字节的字符集，而且都向下兼容ASCII。依次按照GB2312、GBK、GB18030的顺序发展，排前面的是排后面的子集，而我们最常使用的是GBK，它包含的中文字符已经足够我们日常使用，所以平时见到GBK比见到GB18030多。

+ 其他语言地区推出其他的字符集...


按照这个“百花齐放”的形式发展下去，势必严重影响计算机科学的长远发展，每推出一个字符集都会增加一个包袱。为了解决这个问题，人们尝试寻找一套统一的字符集标准，统一这个混乱的局面。

于是同时有两个组织开始研究这件事情，

+ 鼎鼎大名的国际标准化组织ISO推出了ISO/IEC 10646标准，该标准定义了一个统一的字符集："Universal Multiple-Octet Coded Character Set"，简称UCS。它涵盖两种编码方式：UCS-2和UCS-4，分别使用16bit和32bit存储一个字符，可以大致等同于后续介绍的UTF-16和UTF-32，但是UCS-2和UTF-16还是存在一定差别，后续会介绍。

+ 美国一个软件制造商协会推出一套统一字符集：Unicode，最开始它是设计为一个字符存储于2个字节的编码方式，也就是UTF-16，后来支持三种编码方式：UTF-8，UTF-16，UTF-32.

这两个协会后来发现了对方都在做同样的事，于是合并了，结合了彼此的研究成果，所以就诞生了现在的Unicode！！

Unicode只定义了字符集，直白的讲就是定义了哪个数字对应哪个字符而已，但是没有定义这些数字要怎么在计算机中存储，有些数字可能需要1个字节就可以存储，有些则需要2个，3个，甚至4个。这个概念就是所谓的编码，
这就引申出了一个概念：Unicode转换格式（也可以理解为编码方式），全称Unicode Transformation Format，简称UTF。Unicode支持三种编码方式：UTF-8，UTF-16，UTF-32。所以其实常见的`Unicode编码`，这种说法其实不大准确，但是可以注意一点，很多地方默认`Unicode编码`对应的就是UTF-16编码。

UTF-16和UTF-32都是定长的编码方式，分别使用2个字节和4个字节代表一个字符，其中UTF-16是Java默认使用的Unicode编码方式。与UTF-16和UTF-32不同，UTF-8是一个变长的编码方式，UTF-8最开始的定义是可以使用1至6个字节代表一个字符的，后来改为1至4个字节。接下来让我们看看UTF-8编码的原理是怎样的。


## UTF-8的实现原理

UTF-8的编码规则可以概括为二条：
+ 单字节的字符，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。
+ 对于n字节(n = 2,3,4)的字符，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

所以，UTF-8的字符编码区间如下，表格中，x位是有效的二进制位，它们拼接起来就是对应的Unicode，表中的1和0，只是用于描述当前字符占用几个字节。而其中的最小值和最大值，只考虑x位的值。

字节数 | 最小值 | 最大值 | Byte 1 | Byte 2 | Byte 3 | Byte 4
--- | --- | --- | --- | --- | --- | --- 
1|U+0000|U+007F|0xxxxxxx|||
2|U+0080|U+07FF|110xxxxx|10xxxxxx||
3|U+0800|U+FFFF|1110xxxx|10xxxxxx|10xxxxxx|
4|U+10000|U+1FFFFF|11110xxx|10xxxxxx|10xxxxxx|10xxxxxx

接下来举两个例子：

比如，希伯来语字母aleph（א）的Unicode代码是U+05D0，我们按照上面的表格将其转化成UTF-8，U+05D0属于U+0080到U+07FF区域，根据以上表格，说明它使用双字节的格式：110xxxxx 10xxxxxx.
十六进制的0x05D0换算成二进制就是101-1101-0000.这11位数按顺序放入x部分：11010111 10010000.
最后结果用十六进制写起来就是0xD7 0x90，这就是这个字符aleph（א）的UTF-8编码。

再举个例子，汉字“啊"的unicode是U+554A（0101 0101 0100 1010），根据上表，可以发现U+554A处在第三行的范围内（0000 0800-0000 FFFF），因此“啊"的UTF-8编码需要三个字节，即格式是`1110xxxx 10xxxxxx 10xxxxxx`。然后，从“啊"的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位在高位补0。这样就得到了，“啊"的UTF-8编码是"11100101 10010101 10001010"，转换成十六进制就是0xE5958A。
 

Unicode中，单字节留给了ASCII码，而重音文字、希腊字母等使用2字节来存储，而常用的汉字、韩文等亚洲方块字则使用3字节。其他复杂字符则使用4字节。

与其他Unicode编码相比，特别是UTF-16，在UTF-8中ASCII字符占用的空间只有一半，可是在一些字符的UTF-8编码占用的空间就要多出1/3，特别是中文、日文和韩文（CJK）这样的方块文字，UTF-16只需两个字节，而UTF-8需要三个字节。


1、big endian little endian
2、文件头
3、EF、BB、BF  乱码问题

big endian little endian

Unicode、Unicode big endian和UTF-8编码的txt文件的开头会多出几个字节，分别是FF、FE（Unicode）,FE、FF（Unicode big endian）,EF、BB、BF（UTF-8）





http://pcedu.pconline.com.cn/empolder/gj/other/0505/616631_all.html#content_page_2


## Base64编码



## URL编码



